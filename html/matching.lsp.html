<!DOCTYPE HTML PUBLIC "HTML 4.01 Transitional">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>matching.lsp</title>

<link rel="stylesheet" type="text/css" href="newlispdoc.css" />
</head>

<body style="margin: 20px;" text="#111111" bgcolor="#FFFFFF" 
			link="#376590" vlink="#551A8B" alink="#ffAA28">
<blockquote>
<center><h1>matching.lsp</h1></center>
<p><a href="index.html">Module index</a></p><a href="matching.lsp.src.html">source</a>&nbsp;<br/>
<h2>Module:&nbsp;matching</h2><b>Author: </b>Jeff Ober <jeffober@gmail.com><br/>
<b>Version: </b>1.0<br/>
<b>Location: </b><a href="http://static.artfulcode.net/newlisp/matching.lsp">http://static.artfulcode.net/newlisp/matching.lsp</a><br/>
<b>package: </b>http://static.artfulcode.net/newlisp/matching.qwerty<br/>
<p>Complex conditionals using match and unify (updated for newlisp 10)</p>
 <p>Matching conditionals make possible a very terse style of programming common to the
 ML family of languages.</p>
 <h4>Version history</h4>
 <b>1.0</b>
 &bull; updated for newlisp 10
 &bull; renamed module to matching
 &bull; removed dependency on util.lsp
 &bull; made match-bind a global symbol
 &bull; fixed error in documentation for match-cond
 &bull; fixed error in match-cond that bound arguments incorrectly
 &bull; removed match-with and if-match because they were generally confusing and unnecessary
 &bull; match-bind no longer binds exact matches (e.g. 'foo and 'foo), only wildcards
 &bull; fixed bug in match-case where target was bound incorrectly in some cases
<br/><br/>
 <b>0.5</b>
 &bull; fixed bug in <tt>with-match</tt> causing $0 to be misinterpreted in certain circumstances
<br/><br/>
 <b>0.4</b>
 &bull; added <tt>with-match</tt>, a simpler operator that is more idiomatic of newLISP
<br/><br/>
 <b>0.3</b>
 &bull; added <tt>if-match</tt>, <tt>match-with</tt>
<br/><br/>
 <b>0.2</b>
 &bull; altered argument order in <tt>match-cond</tt>
 &bull; added <tt>match-case</tt>
<br/><br/>
 <b>0.1</b>
 &bull; initial release
 &bull; added <tt>match-bind</tt>, <tt>match-let</tt>

<br/><br/><center>&sect;</center><br/>
<a name="_match-bind"></a><h3><font color=#CC0000>match-bind</font></h3>
<b>syntax: (<font color=#CC0000>match-bind</font> <em>vars</em> <em>pattern</em> <em>target</em>)</b><br/>
<b>parameter: </b><em>vars</em> - symbols to bind<br/>
<b>parameter: </b><em>pattern</em> - match pattern<br/>
<b>parameter: </b><em>target</em> - match target<br/>
 <p>If <tt>(match <em>pattern</em> <em>target</em>)</tt> is valid, binds <em>vars</em> to
 the result of its evaluation.</p>
<b>example:</b><blockquote><pre> (match-bind '(a b) '(? ?) '(1 2))
 a =&gt; 1
 b =&gt; 2</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="_match-let"></a><h3><font color=#CC0000>match-let</font></h3>
<b>syntax: (<font color=#CC0000>match-let</font> (<em>vars</em> <em>pattern</em> <em>target</em>) <em>body</em> ...)</b><br/>
<b>parameter: </b><em>vars</em> - symbols to bind<br/>
<b>parameter: </b><em>pattern</em> - match pattern<br/>
<b>parameter: </b><em>target</em> - match target<br/>
<b>parameter: </b><em>body</em> - series of forms to be evaluated<br/>
 <p><tt>match-let</tt> will evaluate body in an environment where
 variables <em>vars</em> are bound to the destructured values from
 <em>target</em> according to match pattern <em>pattern</em>.  Thus, if
 the result of <tt>(match <em>pattern</em> <em>target</em>)</tt> is <tt>(1 2 (3 4))</tt>,
 <em>vars</em> <tt>(a b c)</tt> will be bound as <tt>((a 1) (b 2) (c '(3 4)))</tt>.</p>
 <p>Should <em>pattern</em> not match <em>target</em>, an error is signaled.
 Note that <em>target</em> is evaluated before <em>body</em> is executed.
 <em>target</em> is evaluated even if the match fails, as it is the
 evaluated form against which <em>pattern</em> is matched.</p>
<b>example:</b><blockquote><pre> (let ((lst '(1 2 3 4)))
   (match-let ((a b c) (? ? *) lst)
     (+ a b (apply * c))))
 
 =&gt; 15</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="_match-case"></a><h3><font color=#CC0000>match-case</font></h3>
<b>syntax: (<font color=#CC0000>match-case</font> <em>target</em> (<em>case-pattern</em> <em>case-vars</em> <em>case-expr</em>) ...)</b><br/>
<b>parameter: </b><em>target</em> - the expression to match against<br/>
<b>parameter: </b><em>case-pattern</em> - the pattern to match with <em>target</em><br/>
<b>parameter: </b><em>case-vars</em> - the symbols to bind to the result of the match<br/>
<b>parameter: </b><em>case-expr</em> - the form to be evaluated should <em>case-pattern</em> match successfully<br/>
 <p><tt>match-case</tt> tries a series of match cases in sequence and returns the result of 
 evaluating the first successful match's <em>case-expr</em> in a local scope in which symbols
 <em>case-vars</em> are bound to the result of matching <em>case-pattern</em> against <em>target</em>.</p>
<b>example:</b><blockquote><pre> (let ((x '(1 2 3 4 5)))
   (match-case x
     ((? ? ?) (a b c) (println "this form is not evaluated since '(? ? ?) does not match x"))
     ((? ? *) (a b c) (println "c is bound to " c " in this form"))
     ((*) (a) (println "catch-all")))) ; (*) matches all lists, so it is catch-all for x
 
 =&gt; "c is bound to (3 4 5) in this form"</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="_match-cond"></a><h3><font color=#CC0000>match-cond</font></h3>
<b>syntax: (<font color=#CC0000>match-cond</font> ((<em>pattern</em> <em>vars</em> <em>target</em>) <em>body-forms</em>) ...)</b><br/>
<b>parameter: </b><em>pattern</em> - match pattern<br/>
<b>parameter: </b><em>vars</em> - symbols to bind<br/>
<b>parameter: </b><em>target</em> - match target<br/>
<b>parameter: </b><em>body</em> - series of forms to be evaluated<br/>
 <p><tt>match-cond</tt> evaluates a series of match/bind combinations until one
 of them evaluates non-nil.  The result of the successful match will be bound
 to the symbols in <em>vars</em>, and the associated <em>body-forms</em> will be evaluated
 with those symbols locally bound.  The result of the evaluation is nil if
 no forms match or the result of the final <em>body-form</em> evaluated.</p>
 <p><tt>match-cond</tt> is more versatile than <tt>match-case</tt> in that <tt>match-cond</tt> may
 test against multiple targets and evaluates its <em>body-forms</em> in an implicit
 <tt>begin</tt> block.</p>
<b>example:</b><blockquote><pre> (let ((x '(1 2 3 4 5)))
   (match-cond
     (((? ? ?) (a b c) x) (println "evaluation never gets here"))
     (((? ? *) (a b c) x) (println "c gets bound to " c))
     (((*) (a) x) (println "catch-all")))) ; (*) matches all lists, so is catch-all for x
 
 =&gt; "c gets bound to (3 4 5)"</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="_with-match"></a><h3><font color=#CC0000>with-match</font></h3>
<b>syntax: (<font color=#CC0000>with-match</font> <em>target</em> (<em>match-form-n</em> <em>body-n</em>) ...)</b><br/>
<b>parameter: </b><em>target</em> - target of the match<br/>
<b>parameter: </b><em>match-expr-n</em> - match pattern to be tested against <em>target</em><br/>
<b>parameter: </b><em>body-n</em> - block to be evaluated if <em>match-expr-n</em> matches successfully<br/>
 <p>Tests each <em>match-expr-n</em> in turn against <em>target</em>.  On the first successful match,
 the system variable <tt>$0</tt> is bound to the result of the match and the paired <em>body-n</em> is
 evaluated.  No further match forms are tested after a successful match and the result of
 the evaluation of <em>body-n</em> is returned.  If no match is successful, <tt>nil</tt> is returned.</p>
<b>example:</b><blockquote><pre> (with-match '(1 2 3 (4 5))
   ((? ? ? (? ?)) (apply + $0))
   ((? *) (println "Never gets here")))
 =&gt; 15</pre></blockquote>

<br/><br/><center>- &part; -</center><br/>
<center><font face='Arial' size='-2' color='#444444'>
generated with <a href="http://newlisp.org">newLISP</a>&nbsp;
and <a href="http://newlisp.org/newLISPdoc.html">newLISPdoc</a>
</font></center>
</blockquote>
</body>
</html>
