<!DOCTYPE HTML PUBLIC "HTML 4.01 Transitional">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>sockets.lsp</title>

<link rel="stylesheet" type="text/css" href="newlispdoc.css" />
</head>

<body style="margin: 20px;" text="#111111" bgcolor="#FFFFFF" 
			link="#376590" vlink="#551A8B" alink="#ffAA28">
<blockquote>
<center><h1>sockets.lsp</h1></center>
<p><a href="index.html">Module index</a></p><a href="sockets.lsp.src.html">source</a>&nbsp;<br/>
<h2>Module:&nbsp;Sockets</h2><b>Author: </b>Jeff Ober <jeffober@gmail.com><br/>
<b>Version: </b>1.0<br/>
<b>Location: </b><a href="http://static.artfulcode.net/newlisp/sockets.lsp">http://static.artfulcode.net/newlisp/sockets.lsp</a><br/>
<b>package: </b>http://static.artfulcode.net/newlisp/sockets.qwerty<br/>
<p>Classes for socket operations (requires newlisp 10)</p>
 Sockets are a fast, efficient method for client/server operations. newLisp
 has a broad range of functions for dealing with socket-based connections,
 many of them somewhat arcane if not familiar with socket jargon. The Sockets
 module encapsulates some of this complexity into two simple classes.
 The Socket class provides methods for reading, writing, and sending lisp
 expressions between client and server processes. Requires newlisp 10+ and
 unix sockets.
<br/><br/>
 <h4>Version history</h4>
 <b>1.0</b>
 &bull; initial release (replaces SocketServer module)
<br/><br/>
<b>example:</b><blockquote><pre> ; Fork a server
 (setf pid
   (fork
     (let ((server (SocketServer "/tmp/newlisp.sock")))
      (:run-server server
        (lambda (client server , request)
          (if client
            (begin
              (setf request (:read-expr client))
              (eval request) ; not safe unless you know your client
              (:write-expr client '(println "Hello, client!"))
              (:close client))
            (println "client connection error: " (net-error))))
        nil ; no operations between connections
        (lambda (err server) (println "An error has occurred: " err))))))
  
 (sleep 500) ; give server time to start
 
 ; Connect to server process as a client
 (let ((socket (Sockets:make-file-socket "/tmp/newlisp.sock")))
   (:write-expr socket '(println "Hello, server!"))
   (setf expr (:read-expr socket))
   (:close socket))
 (eval expr) ; not safe unless you know your server
 
 (destroy pid) ; clean up</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="Sockets_make-file-socket"></a><h3><font color=#CC0000>Sockets:make-file-socket</font></h3>
<b>syntax: (<font color=#CC0000>Sockets:make-file-socket</font> <em>str-file</em>)</b><br/>
<b>parameter: </b><em>str-file</em> - a file to use as a socket file<br/>
 <p>Creates a new Socket instance using <em>str-file</em></p>.
<b>example:</b><blockquote><pre> (setf socket (Sockets:create-socket-file "/tmp/my_app.sock"))</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="Sockets_make-network-socket"></a><h3><font color=#CC0000>Sockets:make-network-socket</font></h3>
<b>syntax: (<font color=#CC0000>Sockets:make-network-socket</font> <em>str-host</em> <em>int-port</em>)</b><br/>
<b>parameter: </b><em>str-host</em> - the HTTP hostname of the remote server<br/>
<b>parameter: </b><em>int-port</em> - the remote server's port number to connect to<br/>
 <p>Creates a new Socket instance connected to <em>str-host</em>:<em>int-port</em>.</p>
<b>example:</b><blockquote><pre> (setf socket (Sockets:create-network-soket "http://www.artfulcode.net" 80))</pre></blockquote>
<br/><br/><center>&sect;</center><br/>
<a name="_Socket"></a><h3><font color=#CC0000>Socket</font></h3>
<b>syntax: (<font color=#CC0000>Socket</font> <em>socket</em>)</b><br/>
<b>parameter: </b><em>socket</em> - an open socket file descriptor<br/>
 <p>A Socket is a wrapper around a socket file descriptor and uses the
 built-in net-* functions to manage socket operations.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_socket"></a><h3><font color=#CC0000>:socket</font></h3>
<b>syntax: (<font color=#CC0000>:socket</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Returns the socket file descriptor.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_close"></a><h3><font color=#CC0000>:close</font></h3>
<b>syntax: (<font color=#CC0000>:close</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Closes the socket connection.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_peek"></a><h3><font color=#CC0000>:peek</font></h3>
<b>syntax: (<font color=#CC0000>:peek</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Returns the number of bytes ready to be read from the socket.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_ready?"></a><h3><font color=#CC0000>:ready?</font></h3>
<b>syntax: (<font color=#CC0000>:ready?</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Returns true if the socket is ready for reading.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_write"></a><h3><font color=#CC0000>:write</font></h3>
<b>syntax: (<font color=#CC0000>:write</font> <em>inst</em> <em>str-message</em> [<em>int-chunk-size</em>])</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
<b>parameter: </b><em>str-message</em> - the message to send<br/>
<b>parameter: </b><em>int-chunk-size</em> - optional; sends message in chunks of size <em>int-chunk-size</em><br/>
 <p>Sends <em>str-message</em> along the Socket. If optional <em>int-chunk-size</em> is
 specified, sends the message in chunks.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_read-chunk"></a><h3><font color=#CC0000>:read-chunk</font></h3>
<b>syntax: (<font color=#CC0000>:read-chunk</font> <em>inst</em> <em>int-bytes</em> [<em>block</em>])</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
<b>parameter: </b><em>int-bytes</em> - the number of bytes to read<br/>
<b>parameter: </b><em>block</em> - optional; if explicitly nil, does not block for bytes to be available<br/>
 <p>Blocks until a maximum of <em>int-bytes</em> are available to read from the
 socket and then returns the resulting string. If <em>blocks</em> is explicitly
 passed as nil, returns nil when no bytes are available to read.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_read"></a><h3><font color=#CC0000>:read</font></h3>
<b>syntax: (<font color=#CC0000>:read</font> <em>inst</em> [<em>chunk-size</em> [<em>block</em>]])</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
<b>parameter: </b><em>chunk-size</em> - the number of bytes to read at a time (default is 512)<br/>
<b>parameter: </b><em>block</em> - whether to block for data (default is true)<br/>
 <p>Reads from the socket until there is nothing left to read. Will block
 until something is available to read unless block is nil. This can lead
 to an indefinitely blocking read if neither end closes the connection.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_read-line"></a><h3><font color=#CC0000>:read-line</font></h3>
<b>syntax: (<font color=#CC0000>:read-line</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Reads one line from the socket. Read-line will continue to read from
 socket until and end-line character (\n or \r or both) is found. This
 is not as fast as :read or :read-chunk, as it reads byte-by-byte, and
 should not be used unless the source is trusted!</p>

<br/><br/><center>&sect;</center><br/>
<a name="_write-expr"></a><h3><font color=#CC0000>:write-expr</font></h3>
<b>syntax: (<font color=#CC0000>:write-expr</font> <em>inst</em> <em>expr</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
<b>parameter: </b><em>expr</em> - a quoted lisp expression<br/>
 <p>Sends <em>expr</em> along the socket. The other end of the socket may
 then use :read-expr to read the expression back into lisp. Optionally,
 <em>expr</em> may be a string, in which case it will be converted to the
 expression '(string <em>expr</em>). Combined with :read-expr, this provides a
 simple way to move complex data across a socket connection.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_read-expr"></a><h3><font color=#CC0000>:read-expr</font></h3>
<b>syntax: (<font color=#CC0000>:read-expr</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of Socket<br/>
 <p>Reads an expression from the socket. Returns a valid lisp expression.
 This function will block until a valid lisp expression is encountered.
 Combined with :write-expr, this provides a simple way to move complex
 data across a socket connection.</p>



<br/><br/><center>&sect;</center><br/>
<a name="_SocketServer"></a><h3><font color=#CC0000>SocketServer</font></h3>
<b>syntax: (<font color=#CC0000>SocketServer</font> <em>int-port</em>)</b><br/>
<b>syntax: (<font color=#CC0000>SocketServer</font> <em>str-file</em>)</b><br/>
<b>parameter: </b><em>int-port</em> - the port number to listen on<br/>
<b>parameter: </b><em>str-file</em> - alternately, the socket file to listen on<br/>
 <p>Creates a new SocketServer from a port number or socket file path.
 SocketServer inherits directly from Socket, so all I/O methods from 
 Socket are available to SocketServer instances. Throws an error if it
 encounters a problem creating the socket.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_accept"></a><h3><font color=#CC0000>:accept</font></h3>
<b>syntax: (<font color=#CC0000>:accept</font> <em>inst</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of SocketServer<br/>
 <p>Blocks until a connection is available and returns a new Socket
 instance for the resulting connection.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_until-connection-ready"></a><h3><font color=#CC0000>:until-connection-ready</font></h3>
<b>syntax: (<font color=#CC0000>:until-connection-ready</font> <em>inst</em> <em>func</em> [<em>poll-length</em>])</b><br/>
<b>parameter: </b><em>inst</em> - an instance of SocketServer<br/>
<b>parameter: </b><em>func</em> - a function to call while awaiting a connection<br/>
<b>parameter: </b><em>poll-length</em> - the number of ms to wait for a connection on each poll<br/>
 <p>Repeatedly calls <em>func</em> until a client connection is ready on the socket.
 Optional parameter <em>poll-timeout</em> (milliseconds) controls the length of time
 to wait for a connection before calling func. The function is passed the
 server instance.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_on-connection"></a><h3><font color=#CC0000>:on-connection</font></h3>
<b>syntax: (<font color=#CC0000>:on-connection</font> <em>inst</em> <em>func</em>)</b><br/>
<b>parameter: </b><em>inst</em> - an instance of SocketServer<br/>
<b>parameter: </b><em>func</em> - a function to call when a client connects<br/>
 <p>Blocks for a client connection and then calls <em>func</em> with the client
 socket and the server instance. If an error occurs accepting the connection,
 nil is passed to <em>func</em>. The error is then available via net-error.</p>

<br/><br/><center>&sect;</center><br/>
<a name="_run-server"></a><h3><font color=#CC0000>:run-server</font></h3>
<b>syntax: (<font color=#CC0000>:run-server</font> <em>inst</em> <em>func-connect</em> [<em>func-wait</em> [<em>func-err</em>] [<em>poll-length</em>]])</b><br/>
<b>parameter: </b><em>inst</em> - an instance of SocketServer<br/>
<b>parameter: </b><em>func-connect</em> - called when a client connects<br/>
<b>parameter: </b><em>func-wait</em> - called repeatedly while awaiting a client<br/>
<b>parameter: </b><em>func-err</em> - called when a server error occurs<br/>
<b>parameter: </b><em>poll-length</em> - the number of ms to wait for a connection on each poll<br/>
 <p>Runs the server in a loop. If <em>func-connect</em> is provided, it will be
 called in the event of a server error. It is passed the error string and
 server instance. If <em>func-wait</em> is provided, it will be called repeatedly
 until a client connection is available. The only required parameters are the
 SocketServer instance and <em>func-connect</em>, which will be called when a client
 connection is accepted. It will be passed the client socket and the server
 instance. If <em>func-err</em> is not defined, the server will throw an error when
 an error occurs.</p>










<br/><br/><center>- &part; -</center><br/>
<center><font face='Arial' size='-2' color='#444444'>
generated with <a href="http://newlisp.org">newLISP</a>&nbsp;
and <a href="http://newlisp.org/newLISPdoc.html">newLISPdoc</a>
</font></center>
</blockquote>
</body>
</html>
